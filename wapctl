#!/usr/bin/env python3

import chardet
import io
import os
import re
import sys
import argparse
import platform
import subprocess
from enum import IntEnum
from subprocess import PIPE, DEVNULL

class Shell:

    def traditional(cmd):
        cmdline = "cmd.exe /c \"" + cmd + "\""
        subprocess.Popen(cmdline, shell=True, stdout=DEVNULL, stderr=DEVNULL)

    def ps(cmd):
        cmdline = "powershell.exe -command \"& {" + cmd + "}\""
        if platform.system() == "Windows":
            cmdline = cmdline.replace("\$", "$")
        proc = subprocess.Popen(cmdline, shell=True, stdout=PIPE)
        out, err = proc.communicate()
        return out

class PSArray:

    def __init__(self):
        self.stream = None
        self.nextline = None

    def readline(self):
        if self.stream is None:
            return None
        if self.nextline is None:
            retval = self.stream.readline()
            if retval is None:
                return None
        else:
            retval = self.nextline
        line = self.stream.readline()
        while line is not None and len(line) > 0 and line[0] == " ":
            retval = retval.rstrip() + line.lstrip()
            line = self.stream.readline()
        self.nextline = line
        return retval

    def build(self, cmd, name_key=None, name_target=None):
        self.stream = None
        self.nextline = None

        name_key_u = name_key.upper() if name_key is not None else None
        name_target_u = name_target.upper() if name_target is not None else None

        out = Shell.ps(cmd + "| format-list *")
        if len(out) > 0:
            coding = chardet.detect(out)["encoding"]
            if coding is not None:
                self.stream = io.StringIO(out.decode(coding))

        if self.stream is None:
            return []

        all_list = []
        item_alist = {}
        line = self.readline()
        while line:
            line = line.strip()
            if len(line) > 0:
                name, value = line.split(':', 1)
                name = name.strip()
                name_u = name.upper()
                value = value.strip()
                item_alist.update({name_u: value})
            else:
                if len(item_alist) > 0:
                    if name_key_u is None or name_target_u is None:
                        all_list.append(item_alist)
                    else:
                        if name_target_u in item_alist[name_key_u].upper():
                            all_list.append(item_alist)
                    item_alist = {}
            line = self.readline()

        if len(item_alist) > 0:
            if name_key_u is None or name_target_u is None:
                all_list.append(item_alist)
            else:
                if name_target_u in item_alist[name_key_u].upper():
                    all_list.append(item_alist)
            item_alist = {}

        if name_key_u is not None:
            all_list.sort(key=lambda x:x[name_key_u].upper())

        return all_list

class Mode:

    class Index(IntEnum):
        NONE = -1
        PROCESS = 0
        APPLICATION = 1
        INSTALLED = 2
        PACKAGE = 3
        SERVICE = 4
        STARTUP = 5
        MAX = 6

    class OpIndex(IntEnum):
        NONE = -1
        LIST = 0
        SHOW = 1
        START = 2
        STOP = 3
        REMOVE = 4
        MAX = 5

    name_list = ["PROCESS", "APPLICATION", "INSTALLED", "PACKAGE", "SERVICE", "STARTUP"]
    name_abbrev_list = ["P", "A", "INS", "PKG", "SVC", "RUN"]
    op_name_list = ["LIST", "SHOW", "START", "STOP", "REMOVE"]

    mode_list = None
    target_u = None
    separator = None
    flag_yes = False
    flag_header = False

    @classmethod
    def createModeList(cls, target, sep, flag_yes=False, flag_header=False):
        cls.mode_list = [Process(), Application(), Installed(), Package(), Service(), Startup()]
        if target is not None:
            cls.target_u = target.upper()
        cls.separator = sep
        cls.flag_yes = flag_yes
        cls.flag_header = flag_header
        return cls.mode_list
    
    def __init__(self):
        self.object_func_list = [None] * Mode.OpIndex.MAX
        self.property_func_list = [None] * Mode.OpIndex.MAX
        self.header_func_list = [None] * Mode.OpIndex.MAX
        self.name_key_u = None

    def sep(self):
        return self.separator

    def confirmAllTargets(self):
        if self.flag_yes:
            return True
        if self.target_u is None:
            return input("All targets, ok? [y/N] ").strip() == "y"

    def confirm(self, op_name, name, value, no_by_default = False):
        if self.flag_yes:
            return True
        message = "{} {} ({}), ok?".format(op_name, name, value)
        if no_by_default == True:
            return input(message + " [y/N] ").strip() == "y"
        else:
            return input(message + " [Y/n] ").strip() != "n"

    def warningNoCommandCandidates(self, name):
        print("{}: No command candidates found.".format(name), file=sys.stderr)

    def op(self, op_no):
        if op_no >= Mode.OpIndex.MAX:
            return False
        if self.object_func_list[op_no] is None and self.property_func_list[op_no] is None:
            return False
        if op_no != Mode.OpIndex.LIST and self.confirmAllTargets() == False:
            return False
        object_list = self.prepareObjectList()
        if len(object_list) > 0:
            if self.object_func_list[op_no] is not None:
                if self.flag_header and self.header_func_list[op_no] is not None:
                    self.header_func_list[op_no]()
                for o in object_list:
                    self.object_func_list[op_no](o)
            if self.property_func_list[op_no] is not None:
                props_list = self.preparePropertiesList(object_list)
                if len(props_list) > 0:
                    if self.flag_header and self.header_func_list[op_no] is not None:
                        self.header_func_list[op_no]()
                    for p in props_list:
                        self.property_func_list[op_no](p)
        return True

    def createObjectList(self, cmd):
        ps = PSArray()
        return ps.build(cmd, name_key=self.name_key_u, name_target=self.target_u)

    def createPropertiesList(self, cmd):
        ps = PSArray()
        return ps.build(cmd, name_key=self.name_key_u)

class Process(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.property_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.header_func_list[Mode.OpIndex.SHOW] = self.doPrintHeader
        self.property_func_list[Mode.OpIndex.STOP] = self.doStop
        self.name_key_u = "PROCESSNAME"

    def prepareObjectList(self):
        cmd = "get-process | select id, processname"
        return self.createObjectList(cmd)

    def preparePropertiesList(self, olist):
        sep = ""
        idlist = ""
        for o in olist:
            idlist = idlist + sep + o.get("ID")
            sep = ","
        cmd = "get-process -id " + idlist + " |%{ \$p = \$_; \$x = \$_.id; get-ciminstance -classname Win32_Process -namespace root\\cimv2 -filter \\\"processid = \$x\\\" |%{ \$u = (invoke-cimmethod -inputobject \$_ -methodname getowner); [pscustomobject]@{ id = \$p.id; processname = \$p.processname; domain = \$u.domain; user = \$u.user; cmd = \$_.commandline; priority = \$_.priority; product = \$p.product; productversion = \$p.productversion; company = \$p.company }}}"
        return self.createPropertiesList(cmd)

    def doList(self, o):
        print(o.get("PROCESSNAME"))

    def doShow(self, p):
        domain = p.get("DOMAIN")
        owner = p.get("USER") or ""
        if domain is not None:
            owner = domain + "\\" + owner
        print("{1}{0}{2}{0}{3}{0}{4}{0}{5}{0}{6}{0}{7}{0}{8}".format(self.sep(), p.get("PROCESSNAME"), p.get("ID"), p.get("PRIORITY") or "", owner, p.get("PRODUCT") or "", p.get("PRODUCTVERSION") or "", p.get("COMPANY") or "", p.get("CMD") or ""))

    def doStop(self, p):
        if self.confirm("Stop", p.get("PROCESSNAME"), p.get("ID")):
            Shell.ps("stop-process -id " + p.get("ID"))

    def doPrintHeader(self):
        print("{1}{0}{2}{0}{3}{0}{4}{0}{5}{0}{6}{0}{7}{0}{8}".format(self.sep(), "name", "pid", "priority", "owner", "product", "version", "company", "command"))

class Application(Mode):
        
    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.object_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.header_func_list[Mode.OpIndex.SHOW] = self.doPrintHeader
        self.object_func_list[Mode.OpIndex.START] = self.doStart
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd = "(new-object -com shell.application).namespace(\\\"shell:appsfolder\\\").items() | select-object name, path"
        return self.createObjectList(cmd)

    def doList(self, o):
        print(o.get("NAME"))

    def doShow(self, o):
        print("{1}{0}{2}".format(self.sep(), o.get("NAME"), o.get("PATH")))

    def doStart(self, o):
        if o.get("NAME") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Run", o.get("NAME"), o.get("PATH")):
                Shell.ps("start-process \\\"shell:appsfolder\\" + o.get("PATH") + "\\\"")

    def doPrintHeader(self):
        print("{1}{0}{2}".format(self.sep(), "name", "path"))

class Installed(Mode):
        
    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.object_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.header_func_list[Mode.OpIndex.SHOW] = self.doPrintHeader
        self.object_func_list[Mode.OpIndex.REMOVE] = self.doRemove
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd = "get-item (\\\"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\\\", \\\"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\\\", \\\"HKLM:\\Software\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\\\") |%{ \$k = \$_; \$k.getvalue(\\\"UninstallString\\\") |% { if (\$_ -ne \$null) { [pscustomobject]@{ key = \$k.pspath; name = \$k.getvalue(\\\"DisplayName\\\"); version = \$k.getvalue(\\\"DisplayVersion\\\"); publisher = \$k.getvalue(\\\"Publisher\\\"); uninstall = \$_ }}}}"
        return self.createObjectList(cmd)

    def doList(self, o):
        if len(o.get("NAME")) > 0:
            print(o.get("NAME"))

    def doShow(self, o):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), o.get("NAME") or "", o.get("VERSION") or "", o.get("PUBLISHER") or "", o.get("UNINSTALL") or ""))

    def doRemove(self, o):
        if o.get("UNINSTALL") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Uninstall", o.get("NAME"), o.get("UNINSTALL"), no_by_default=True):
                Shell.traditional(o.get("UNINSTALL"))

    def doPrintHeader(self):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), "name", "version", "publisher", "uninstall"))

class Package(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.property_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.header_func_list[Mode.OpIndex.SHOW] = self.doPrintHeader
        self.property_func_list[Mode.OpIndex.START] = self.doStart
        self.object_func_list[Mode.OpIndex.REMOVE] = self.doRemove
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd = "get-appxpackage *"
        return self.createObjectList(cmd)

    def preparePropertiesList(self, olist):
        sep = ""
        name_list = ""
        for o in olist:
            name_list = name_list + sep + "\\\"" + o.get("NAME") + "\\\""
            sep = ","
        cmd = "(" + name_list + ") |%{ get-appxpackage -name \$_ |%{ \$x = \$_; \$q = (get-appxpackagemanifest -package \$x).package; \$p = \$q.properties; \$a = \$q.applications.application; [pscustomobject]@{ name = \$x.name; packagefullname = \$x.packagefullname; packagefamilyname = \$x.packagefamilyname; publisherdisplayname = \$p.publisherdisplayname; apid = \$a.id; executable = \$a.executable } }}"
        return self.createPropertiesList(cmd)

    def doList(self, o):
        print(o.get("NAME"))

    def doShow(self, p):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), p.get("NAME"), p.get("PACKAGEFULLNAME"), p.get("PUBLISHERDISPLAYNAME") or "", p.get("EXECUTABLE") or ""))

    def doStart(self, p):
        if p.get("PACKAGEFAMILYNAME") is None:
            self.warningNoCommandCandidates(p.get("NAME"))
        else:
            if self.confirm("Start", p.get("NAME"), p.get("PACKAGEFAMILYNAME")):
                Shell.ps("start-process \\\"shell:appsfolder\\" + p.get("PACKAGEFAMILYNAME") + "!" + p.get("APID") + "\\\"")

    def doRemove(self, o):
        if o.get("PACKAGEFULLNAME") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Uninstall", o.get("NAME"), o.get("PACKAGEFULLNAME"), no_by_default=True):
                Shell.ps("remove-appxpackage \\\"" + o.get("PACKAGEFULLNAME") + "\\\"")

    def doPrintHeader(self):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), "name", "package", "publisher", "executable"))

class Service(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.property_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.header_func_list[Mode.OpIndex.SHOW] = self.doPrintHeader
        self.property_func_list[Mode.OpIndex.START] = self.doStart
        self.property_func_list[Mode.OpIndex.STOP] = self.doStop
        self.name_key_u = "DISPLAYNAME"

    def prepareObjectList(self):
        cmd = "get-service | select-object name, displayname"
        return self.createObjectList(cmd)

    def preparePropertiesList(self, olist):
        sep = ""
        name_list = ""
        for o in olist:
            name_list = name_list + sep + "name=\'" + o.get("NAME") + "\'"
            sep = " or "
        cmd = "get-ciminstance -class win32_service -filter \\\"" + name_list + "\\\" | select-object name, displayname, processid, startmode, state, pathname"
        return self.createPropertiesList(cmd)

    def doList(self, o):
        print(o.get("DISPLAYNAME"))

    def doShow(self, p):
        print("{1}{0}{2}{0}{3}{0}{4}{0}{5}{0}{6}".format(self.sep(), p.get("DISPLAYNAME"), p.get("NAME") or "", p.get("STARTMODE") or "", p.get("STATE") or "", p.get("PROCESSID") or "", p.get("PATHNAME") or ""))

    def doStart(self, p):
        if p.get("NAME") is None:
            self.warningNoCommandCandidates(p.get("DISPLAYNAME"))
        else:
            if self.confirm("Start", p.get("DISPLAYNAME"), p.get("NAME")):
                Shell.ps("(get-wmiobject win32_service | where-object name -eq \"" + p.get("NAME") + "\").startservice()")

    def doStop(self, p):
        if p.get("NAME") is None:
            self.warningNoCommandCandidates(p.get("DISPLAYNAME"))
        else:
            if self.confirm("Stop", p.get("DISPLAYNAME"), p.get("NAME")):
                Shell.ps("(get-wmiobject win32_service | where-object name -eq \"" + p.get("NAME") + "\").stopservice()")

    def doPrintHeader(self):
        print("{1}{0}{2}{0}{3}{0}{4}{0}{5}{0}{6}".format(self.sep(), "name", "internal", "mode", "state", "pid", "path"))

class Startup(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.object_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.header_func_list[Mode.OpIndex.SHOW] = self.doPrintHeader
        self.object_func_list[Mode.OpIndex.START] = self.doStart
        self.object_func_list[Mode.OpIndex.STOP] = self.doStop
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd = "\$r = @(); \$ns = \\\"\\\\Software\\\\\\\"; \$nw = \\\"Microsoft\\\\Windows\\\\CurrentVersion\\\\\\\"; \$nr = \$nw + \\\"Run\\\"; \$ne = \\\":\\\" + \$ns + \$nw + \\\"Explorer\\\\StartupApproved\\\\*\\\"; \$nm = \\\"HKLM:\\\" + \$ns; \$nc = \\\"HKCU:\\\" + \$ns; \$l = @(\\\"User\\\", \\\"System\\\", \\\"WoW\\\"); \$e = @(\$nc, \$nm, (\$nm + \\\"Wow6432Node\\\\\\\")); \$f = @(\\\"\\\", \\\"Common \\\"); foreach (\$i in 0..2) { \$k = get-item (\$e[\$i] + \$nr); \$k.getvaluenames() |%{ \$r += [pscustomobject]@{ l = \\\"Run:\\\" + \$l[\$i]; n = \$_; c = \$k.getvalue(\$_) }}}; foreach (\$i in 0..1) { ((new-object -com shell.application).namespace(\\\"shell:\\\" + \$f[\$i] + \\\"Startup\\\").items() |%{ \$r += [pscustomobject]@{ l = \\\"Startup:\\\" + \$l[\$i]; n = \$_.name; c = \$_.path }})}; \$x = get-itemproperty (\\\"HKLM\\\" + \$ne), (\\\"HKCU\\\" + \$ne); \$nuwp = (\$r |? command -ne \\\"\\\" |%{ \$o = [pscustomobject]@{ location = \$_.l; name = \$_.n; disabled = 0; command = \$_.c; path = \$null }; \$x |%{ \$p = \$_.PSPath; \$_ | get-member -type noteproperty |? name -eq \$o.name |%{ \$v = get-itempropertyvalue \$p -name \$o.name; \$o.path = \$p; \$o.disabled = \$v[0] -band 1 }}; \$o }); \$uwp = (get-appxpackage |% { \$x = \$_; \$t = (get-appxpackagemanifest \$_).package.applications.application.extensions.extension |? category -like \\\"*.startuptask\\\"; if (\$t -ne \$null) { \$p = \$nc + \\\"Classes\\\\Local Settings\\\" + \$ns + \$nw + \\\"AppModel\\\\SystemAppData\\\\\\\" + \$x.packagefamilyname + \\\"\\\\\\\" + \$t.startuptask.taskid; \$s = (get-item \$p).getvalue(\\\"state\\\"); \$o = [pscustomobject]@{ location = \\\"UWP\\\"; name = \$x.name; disabled = \$s -band 1; command = \$x.installlocation + \\\"\\\\\\\" + \$t.executable; path = \$p }; \$o }}); \$nuwp+\$uwp"
        object_list = self.createObjectList(cmd)
        return sorted(object_list, key=lambda x:x["NAME"].upper())

    def state(self, o):
        f = o.get("DISABLED")
        if f is None:
            return None 
        return "disabled" if (f == "1") else "enabled"

    def taskType(self, o):
        return o.get("LOCATION")

    def doList(self, o):
        print(o.get("NAME"))

    def doShow(self, o):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), o.get("NAME") or "", o.get("LOCATION") or "", self.state(o) or "", o.get("COMMAND") or ""))

    def doStart(self, o):
        if o.get("NAME") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Enable", o.get("NAME"), self.state(o)):
                if self.taskType(o) == "UWP":
                    Shell.ps("set-itemproperty -path \\\"" + o.get("PATH") + "\\\" -name state -value 2")
                else:
                    Shell.ps("\$k = \\\"" + o.get("PATH") + "\\\"; \$n = \\\"" + o.get("NAME") + "\\\"; \$v = get-itempropertyvalue \$k -name \$n; \$v[0] = \$v[0] -band 0xfe; set-itemproperty \$k -name \$n -value \$v")

    def doStop(self, o):
        if o.get("NAME") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Disable", o.get("NAME"), self.state(o)):
                if self.taskType(o) == "UWP":
                    Shell.ps("set-itemproperty -path \\\"" + o.get("PATH") + "\\\" -name state -value 1")
                else:
                    Shell.ps("\$k = \\\"" + o.get("PATH") + "\\\"; \$n = \\\"" + o.get("NAME") + "\\\"; \$v = get-itempropertyvalue \$k -name \$n; \$v[0] = \$v[0] -bor 1; set-itemproperty \$k -name \$n -value \$v")

    def doPrintHeader(self):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), "name", "location", "state", "command"))

if __name__ == "__main__":

    msg_desc = "Windows application control"
    msg_epilog = """Example:
  {0} p|process [list|show|stop [<name>]]
  {0} a|appilcation [list|show|start [<name>]]
  {0} ins|installed [list|show|remove [<name>]]
  {0} pkg|package [list|show|start|remove [<name>]]
  {0} svc|service [list|show|start|stop [<name>]]
  {0} run|startup [list|show|start|stop [<name>]]""".format(os.path.basename(__file__))

    parser = argparse.ArgumentParser(description=msg_desc, epilog=msg_epilog, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("mode", help="""p|process     Running processes
a|application Application programs in Shell:AppsFolder
ins|installed Installed applications in 'Uninstall' registry
pkg|package   Packages registered in Windows Store
svc|service   Win32 Services
run|startup   Startup programs in Shell startup, 'Run' registry and UWP""")
    parser.add_argument("op", nargs="?", default=Mode.op_name_list[Mode.OpIndex.LIST], help="list|show|start|stop|remove")
    parser.add_argument("target", nargs="?", default=None, help="target name")
    parser.add_argument("-s", "--separator", nargs=1, default=" ", help="field separator for output")
    parser.add_argument("-y", "--yes", action="store_true", help="assume yes")
    parser.add_argument("-H", "--print-header", action="store_true", help="print header")
    args = parser.parse_args()

    mode_no = Mode.Index.NONE
    mu = args.mode.upper()
    for (i, c) in enumerate(Mode.name_list):
        if mu == c:
            mode_no = i
    if mode_no == Mode.Index.NONE:
        for (i, c) in enumerate(Mode.name_abbrev_list):
            if mu == c:
                mode_no = i

    op_no = Mode.OpIndex.NONE
    ou = args.op.upper()
    for (i, c) in enumerate(Mode.op_name_list):
        if ou == c:
            op_no = i

    if mode_no == Mode.Index.NONE or op_no == Mode.OpIndex.NONE:
        parser.print_help(file=sys.stderr)
        exit(1)

    mode_list = Mode.createModeList(args.target, args.separator[0], args.yes, args.print_header)
    if mode_list[mode_no].op(op_no) == False:
        exit(1)

    exit(0)
