#!/usr/bin/env python3

import chardet
import io
import os
import re
import sys
import argparse
import subprocess
from enum import IntEnum
from subprocess import PIPE, DEVNULL

class Shell:

    def traditional(cmd):
        cmdline = "cmd.exe /c \"" + cmd + "\""
        subprocess.Popen(cmdline, shell=True, stdout=DEVNULL, stderr=DEVNULL)

    def ps(cmd):
        cmdline = "powershell.exe -command \"& {" + cmd + "}\""
        proc = subprocess.Popen(cmdline, shell=True, stdout=PIPE)
        out, err = proc.communicate()
        return out

class PSArray:

    def __init__(self):
        self.stream = None
        self.nextline = None

    def readline(self):
        if self.stream is None:
            return None
        if self.nextline is None:
            retval = self.stream.readline()
            if retval is None:
                return None
        else:
            retval = self.nextline
        line = self.stream.readline()
        while line is not None and len(line) > 0 and line[0] == " ":
            retval = retval.rstrip() + line.lstrip()
            line = self.stream.readline()
        self.nextline = line
        return retval

    def build(self, cmd, name_key=None, name_target=None):
        self.stream = None
        self.nextline = None

        name_key_u = name_key.upper() if name_key is not None else None
        name_target_u = name_target.upper() if name_target is not None else None

        out = Shell.ps(cmd + "| format-list *")
        if len(out) > 0:
            coding = chardet.detect(out)["encoding"]
            if coding is not None:
                self.stream = io.StringIO(out.decode(coding))

        if self.stream is None:
            return []

        all_list = []
        item_alist = {}
        line = self.readline()
        while line:
            line = line.strip()
            if len(line) > 0:
                name, value = line.split(':', 1)
                name = name.strip()
                name_u = name.upper()
                value = value.strip()
                item_alist.update({name_u: value})
            else:
                if len(item_alist) > 0:
                    if name_key_u is None or name_target_u is None:
                        all_list.append(item_alist)
                    else:
                        if name_target_u in item_alist[name_key_u].upper():
                            all_list.append(item_alist)
                    item_alist = {}
            line = self.readline()

        if len(item_alist) > 0:
            if name_key_u is None or name_target_u is None:
                all_list.append(item_alist)
            else:
                if name_target_u in item_alist[name_key_u].upper():
                    all_list.append(item_alist)
            item_alist = {}

        if name_key_u is not None:
            all_list.sort(key=lambda x:x[name_key_u].upper())

        return all_list

class Mode:

    class Index(IntEnum):
        NONE = -1
        PROCESS = 0
        APPLICATION = 1
        INSTALLED = 2
        PACKAGE = 3
        SERVICE = 4
        STARTUP = 5
        MAX = 6

    class OpIndex(IntEnum):
        NONE = -1
        LIST = 0
        SHOW = 1
        START = 2
        STOP = 3
        REMOVE = 4
        MAX = 5

    name_list = ["PROCESS", "APPLICATION", "INSTALLED", "PACKAGE", "SERVICE", "STARTUP"]
    name_abbrev_list = ["P", "A", "INS", "PKG", "SVC", "RUN"]
    op_name_list = ["LIST", "SHOW", "START", "STOP", "REMOVE"]

    mode_list = None
    target_u = None
    separator = None
    flag_yes = False

    @classmethod
    def createModeList(cls, target, sep, flag_yes=False):
        cls.mode_list = [Process(), Application(), Installed(), Package(), Service(), Startup()]
        if target is not None:
            cls.target_u = target.upper()
        cls.separator = sep
        cls.flag_yes = flag_yes
        return cls.mode_list
    
    def __init__(self):
        self.object_func_list = [None] * Mode.OpIndex.MAX
        self.property_func_list = [None] * Mode.OpIndex.MAX
        self.name_key_u = None

    def sep(self):
        return self.separator

    def confirmAllTargets(self):
        if self.flag_yes:
            return True
        if self.target_u is None:
            return input("All targets, ok? [y/N] ").strip() == "y"

    def confirm(self, op_name, name, value, no_by_default = False):
        if self.flag_yes:
            return True
        message = "{} {} ({}), ok?".format(op_name, name, value)
        if no_by_default == True:
            return input(message + " [y/N] ").strip() == "y"
        else:
            return input(message + " [Y/n] ").strip() != "n"

    def warningNoCommandCandidates(self, name):
        print("{}: No command candidates found.".format(name), file=sys.stderr)

    def op(self, op_no):
        if op_no >= Mode.OpIndex.MAX:
            return False
        if self.object_func_list[op_no] is None and self.property_func_list[op_no] is None:
            return False
        if op_no != Mode.OpIndex.LIST and self.confirmAllTargets() == False:
            return False
        object_list = self.prepareObjectList()
        if len(object_list) > 0:
            if self.object_func_list[op_no] is not None:
                for o in object_list:
                    self.object_func_list[op_no](o)
            if self.property_func_list[op_no] is not None:
                props_list = self.preparePropertiesList(object_list)
                if len(props_list) > 0:
                    for p in props_list:
                        self.property_func_list[op_no](p)
        return True

    def createObjectList(self, cmd):
        ps = PSArray()
        return ps.build(cmd, name_key=self.name_key_u, name_target=self.target_u)

    def createPropertiesList(self, cmd):
        ps = PSArray()
        return ps.build(cmd, name_key=self.name_key_u)

class Process(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.property_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.property_func_list[Mode.OpIndex.STOP] = self.doStop
        self.name_key_u = "PROCESSNAME"

    def prepareObjectList(self):
        cmd = "get-process | select id, processname"
        return self.createObjectList(cmd)

    def preparePropertiesList(self, olist):
        sep = ""
        idlist = ""
        for o in olist:
            idlist = idlist + sep + o.get("ID")
            sep = ","
        cmd = "get-process -id " + idlist + " |%{ \$p = \$_; \$x = \$_.id; get-ciminstance -classname Win32_Process -namespace root\\cimv2 -filter \\\"processid = \$x\\\" |%{ \$u = (invoke-cimmethod -inputobject \$_ -methodname getowner); [pscustomobject]@{ id = \$p.id; processname = \$p.processname; domain = \$u.domain; user = \$u.user; cmd = \$_.commandline; priority = \$_.priority; product = \$p.product; productversion = \$p.productversion; company = \$p.company }}}"
        return self.createPropertiesList(cmd)

    def doList(self, o):
        print(o.get("PROCESSNAME"))

    def doShow(self, p):
        domain = p.get("DOMAIN")
        owner = p.get("USER") or ""
        if domain is not None:
            owner = domain + "\\" + owner
        print("{1}{0}{2}{0}{3}{0}{4}{0}{5}{0}{6}{0}{7}{0}{8}".format(self.sep(), p.get("PROCESSNAME"), p.get("ID"), p.get("PRIORITY") or "", owner, p.get("PRODUCT") or "", p.get("PRODUCTVERSION") or "", p.get("COMPANY") or "", p.get("CMD") or ""))

    def doStop(self, p):
        if self.confirm("Stop", p.get("PROCESSNAME"), p.get("ID")):
            Shell.ps("stop-process -id " + p.get("ID"))

class Application(Mode):
        
    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.object_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.object_func_list[Mode.OpIndex.START] = self.doStart
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd = "(new-object -com shell.application).namespace(\\\"shell:appsfolder\\\").items() | select-object name, path"
        return self.createObjectList(cmd)

    def doList(self, o):
        print(o.get("NAME"))

    def doShow(self, o):
        print("{1}{0}{2}".format(self.sep(), o.get("NAME"), o.get("PATH")))

    def doStart(self, o):
        if o.get("NAME") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Run", o.get("NAME"), o.get("PATH")):
                Shell.ps("start-process \\\"shell:appsfolder\\\\" + o.get("PATH") + "\\\"")

class Installed(Mode):
        
    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.object_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.object_func_list[Mode.OpIndex.REMOVE] = self.doRemove
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd = "get-item (\\\"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\\\", \\\"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\\\", \\\"HKLM:\\Software\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\\\") |%{ \$k = \$_; \$k.getvalue(\\\"UninstallString\\\") |% { if (\$_ -ne \$null) { [pscustomobject]@{ key = \$k.pspath; name = \$k.getvalue(\\\"DisplayName\\\"); version = \$k.getvalue(\\\"DisplayVersion\\\"); publisher = \$k.getvalue(\\\"Publisher\\\"); uninstall = \$_ }}}}"
        return self.createObjectList(cmd)

    def doList(self, o):
        if len(o.get("NAME")) > 0:
            print(o.get("NAME"))

    def doShow(self, o):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), o.get("NAME") or "", o.get("VERSION") or "", o.get("PUBLISHER") or "", o.get("UNINSTALL") or ""))

    def doRemove(self, o):
        if o.get("UNINSTALL") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Uninstall", o.get("NAME"), o.get("UNINSTALL"), no_by_default=True):
                Shell.traditional(o.get("UNINSTALL"))

class Package(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.property_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.property_func_list[Mode.OpIndex.START] = self.doStart
        self.object_func_list[Mode.OpIndex.REMOVE] = self.doRemove
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd = "get-appxpackage *"
        return self.createObjectList(cmd)

    def preparePropertiesList(self, olist):
        sep = ""
        name_list = ""
        for o in olist:
            name_list = name_list + sep + "\\\"" + o.get("NAME") + "\\\""
            sep = ","
        cmd = "(" + name_list + ") |%{ get-appxpackage -name \$_ |%{ \$x = \$_; \$q = (get-appxpackagemanifest -package \$x).package; \$p = \$q.properties; \$a = \$q.applications.application; [pscustomobject]@{ name = \$x.name; packagefullname = \$x.packagefullname; packagefamilyname = \$x.packagefamilyname; publisherdisplayname = \$p.publisherdisplayname; apid = \$a.id; executable = \$a.executable } }}"
        return self.createPropertiesList(cmd)

    def doList(self, o):
        print(o.get("NAME"))

    def doShow(self, p):
        print("{1}{0}{2}{0}{3}{0}{4}".format(self.sep(), p.get("NAME"), p.get("PACKAGEFULLNAME"), p.get("PUBLISHERDISPLAYNAME") or "", p.get("EXECUTABLE") or ""))

    def doStart(self, p):
        if p.get("PACKAGEFAMILYNAME") is None:
            self.warningNoCommandCandidates(p.get("NAME"))
        else:
            if self.confirm("Start", p.get("NAME"), p.get("PACKAGEFAMILYNAME")):
                Shell.ps("start-process \\\"shell:appsfolder\\\\" + p.get("PACKAGEFAMILYNAME") + "!" + p.get("APID") + "\\\"")

    def doRemove(self, o):
        if o.get("PACKAGEFULLNAME") is None:
            self.warningNoCommandCandidates(o.get("NAME"))
        else:
            if self.confirm("Uninstall", o.get("NAME"), o.get("PACKAGEFULLNAME"), no_by_default=True):
                Shell.ps("remove-appxpackage \\\"" + o.get("PACKAGEFULLNAME") + "\\\"")

class Service(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.property_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.property_func_list[Mode.OpIndex.START] = self.doStart
        self.property_func_list[Mode.OpIndex.STOP] = self.doStop
        self.name_key_u = "DISPLAYNAME"

    def prepareObjectList(self):
        cmd = "get-service | select-object name, displayname"
        return self.createObjectList(cmd)

    def preparePropertiesList(self, olist):
        sep = ""
        name_list = ""
        for o in olist:
            name_list = name_list + sep + "name=\'" + o.get("NAME") + "\'"
            sep = " or "
        cmd = "get-ciminstance -class win32_service -filter \\\"" + name_list + "\\\" | select-object name, displayname, processid, startmode, state, pathname"
        return self.createPropertiesList(cmd)

    def doList(self, o):
        print(o.get("DISPLAYNAME"))

    def doShow(self, p):
        print("{1}{0}{2}{0}{3}{0}{4}{0}{5}{0}{6}".format(self.sep(), p.get("DISPLAYNAME"), p.get("NAME") or "", p.get("STARTMODE") or "", p.get("STATE") or "", p.get("PROCESSID") or "", p.get("PATHNAME") or ""))

    def doStart(self, p):
        if p.get("NAME") is None:
            self.warningNoCommandCandidates(p.get("DISPLAYNAME"))
        else:
            if self.confirm("Start", p.get("DISPLAYNAME"), p.get("NAME")):
                Shell.ps("(get-wmiobject win32_service | where-object name -eq \"" + p.get("NAME") + "\").startservice()")

    def doStop(self, p):
        if p.get("NAME") is None:
            self.warningNoCommandCandidates(p.get("DISPLAYNAME"))
        else:
            if self.confirm("Stop", p.get("DISPLAYNAME"), p.get("NAME")):
                Shell.ps("(get-wmiobject win32_service | where-object name -eq \"" + p.get("NAME") + "\").stopservice()")

class Startup(Mode):

    def __init__(self):
        super().__init__()
        self.object_func_list[Mode.OpIndex.LIST] = self.doList
        self.property_func_list[Mode.OpIndex.SHOW] = self.doShow
        self.property_func_list[Mode.OpIndex.START] = self.doStart
        self.property_func_list[Mode.OpIndex.STOP] = self.doStop
        self.object_func_list[Mode.OpIndex.REMOVE] = self.doRemove
        self.name_key_u = "NAME"

    def prepareObjectList(self):
        cmd_reg = "\$k1 = get-item \\\"HKCU:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"; \$r1 = (\$k1.getvaluenames() |%{ \$n = \$_; [pscustomobject]@{ id = \$k1.pspath + \\\"\\\\\\\" + \$n; name = \$n; type = \$k1.getvaluekind(\$n); command = \$k1.getvalue(\$n) }}); \$k2 = get-item \\\"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"; \$r2 = (\$k2.getvaluenames() |%{ \$n = \$_; [pscustomobject]@{ id = \$k2.pspath + \\\"\\\\\\\" + \$n; name = \$n; type = \$k2.getvaluekind(\$n); command = \$k2.getvalue(\$n) }}); \$k3 = get-item \\\"HKLM:\\\\SOFTWARE\\\\Wow6432Node\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\"; \$r3 = (\$k3.getvaluenames() |%{ \$n = \$_; [pscustomobject]@{ id = \$k3.pspath + \\\"\\\\\\\" + \$n; name = \$n; type = \$k3.getvaluekind(\$n); command = \$k3.getvalue(\$n) }})"
        cmd_shell = "\$r4 = ((new-object -com shell.application).namespace(\\\"shell:Startup\\\").items() |%{ [pscustomobject]@{ id = \\\"Shell:Startup\\\\\\\" + \$_.name; name = \$_.name; type = \$_.type; command = \$_.path }}); \$r5 = ((new-object -com shell.application).namespace(\\\"shell:Common Startup\\\").items() |%{ [pscustomobject]@{ id = \\\"Shell:Common Startup\\\\\\\" + \$_.name; name= \$_.name; type = \$_.type; command = \$_.path }})"
        cmd = "{};{};{}".format(cmd_reg, cmd_shell, "\$r1, \$r2, \$r3, \$r4, \$r5")
        object_list = self.createObjectList(cmd)
        return sorted(object_list, key=lambda x:x["NAME"].upper())

    def preparePropertiesList(self, olist):
        sep = ""
        name_list = ""
        for o in olist:
            name_list = name_list + sep + "\\\"" + o.get("NAME") + "\\\""
            sep = ","
        cmd = "\$a = foreach (\$n in " + name_list + ") { \$x = get-itemproperty \\\"HKLM:\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\StartupApproved\\\\*\\\", \\\"HKCU:\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\StartupApproved\\\\*\\\"; \$x |%{ \$p = \$_.PSPath; \$_ | get-member -type noteproperty |? name -eq \$n |%{ \$v = get-itempropertyvalue \$p -name \$n; [pscustomobject]@{ path = \$p; name = \$n; disabled = \$v[0] -band 1 }}}}; \$a"
        return self.createPropertiesList(cmd)

    def state(self, p):
        f = p.get("DISABLED")
        if f is None:
            return None 
        return "disabled" if (f == "1") else "enabled"

    def doList(self, o):
        print(o.get("NAME"))

    def doShow(self, p):
        loc, typ = p.get("PATH").rsplit("\\", 1)
        print("{1}{0}{2}{0}{3}".format(self.sep(), p.get("NAME") or "", typ, self.state(p) or ""))

    def doStart(self, p):
        if p.get("NAME") is None:
            self.warningNoCommandCandidates(p.get("NAME"))
        else:
            if self.confirm("Enable", p.get("NAME"), self.state(p)):
                Shell.ps("\$k = \\\"" + p.get("PATH") + "\\\"; \$n = \\\"" + p.get("NAME") + "\\\"; \$v = get-itempropertyvalue \$k -name \$n; \$v[0] = \$v[0] -band 0xfe; set-itemproperty \$k -name \$n -value \$v")

    def doStop(self, p):
        if p.get("NAME") is None:
            self.warningNoCommandCandidates(p.get("NAME"))
        else:
            if self.confirm("Disable", p.get("NAME"), self.state(p)):
                Shell.ps("\$k = \\\"" + p.get("PATH") + "\\\"; \$n = \\\"" + p.get("NAME") + "\\\"; \$v = get-itempropertyvalue \$k -name \$n; \$v[0] = \$v[0] -bor 1; set-itemproperty \$k -name \$n -value \$v")

    def doRemove(self, p):
        if (p.get("ID"))[0:6].upper() == "SHELL:":
            if p.get("VALUE") is None:
                self.warningNoCommandCandidates(p.get("NAME"))
            else:
                if self.confirm("Remove", p.get("NAME"), p.get("COMMAND"), no_by_default=True):
                    Shell.ps("remove-item \\\"" + p.get("COMMAND") + "\\\"")
        else:
            kv = p.get("ID").rsplit("\\", 1)
            if self.confirm("Remove", p.get("NAME"), p.get("ID"), no_by_default=True):
                Shell.ps("remove-itemproperty \\\"" + kv[0] + "\\\" -name \\\"" + kv[1] + "\\\"")

if __name__ == "__main__":

    msg_desc = "Windows application control"
    msg_epilog = """Example:
  {0} p|process [list|show|stop [<name>]]
  {0} a|appilcation [list|show|start [<name>]]
  {0} ins|installed [list|show|remove [<name>]]
  {0} pkg|package [list|show|start|remove [<name>]]
  {0} svc|service [list|show|start|stop [<name>]]
  {0} run|startup [list|show|start|stop|remove [<name>]]""".format(os.path.basename(__file__))

    parser = argparse.ArgumentParser(description=msg_desc, epilog=msg_epilog, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("mode", help="""p|process     Running processes
a|application Application programs in Shell:AppsFolder
ins|installed Installed applications in 'Uninstall' registry
pkg|package   Packages registered in Windows Store
svc|service   Win32 Services
run|startup   Startup programs in Shell:Startup and 'Run' registry""")
    parser.add_argument("op", nargs="?", default=Mode.op_name_list[Mode.OpIndex.LIST], help="list|show|start|stop|remove")
    parser.add_argument("target", nargs="?", default=None, help="target name")
    parser.add_argument("-s", "--separator", nargs=1, default=" ", help="field separator for output")
    parser.add_argument("-y", "--yes", action="store_true", help="assume yes")
    args = parser.parse_args()

    mode_no = Mode.Index.NONE
    mu = args.mode.upper()
    for (i, c) in enumerate(Mode.name_list):
        if mu == c:
            mode_no = i
    if mode_no == Mode.Index.NONE:
        for (i, c) in enumerate(Mode.name_abbrev_list):
            if mu == c:
                mode_no = i

    op_no = Mode.OpIndex.NONE
    ou = args.op.upper()
    for (i, c) in enumerate(Mode.op_name_list):
        if ou == c:
            op_no = i

    if mode_no == Mode.Index.NONE or op_no == Mode.OpIndex.NONE:
        parser.print_help(file=sys.stderr)
        exit(1)

    mode_list = Mode.createModeList(args.target, args.separator[0], args.yes)
    if mode_list[mode_no].op(op_no) == False:
        exit(1)

    exit(0)
